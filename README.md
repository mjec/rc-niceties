# rc-niceties

An application to manage niceties delivered by [recursers](https://recurse.com) at the end of their batch.

## Application architecture

This application is pretty simple. It stores niceties as text and some metadata associated with a unique (author, recipient, batch) tuple. This is stored in a Postgres database. Faculty can view and edit all the niceties. Recursers can see all the nice things said about them, and all the things they have said in the past.

The backend is in [Flask](https://flask.palletsprojects.com/en/1.1.x/), and is just a REST API. The DB is Postgres, with [SQLAlchemy](https://docs.sqlalchemy.org/en/13/) as an ORM and [Alembic](https://alembic.sqlalchemy.org/en/latest/#) to manage schema migrations. The frontend is in [react](https://reactjs.org/), because it's 2016 and that's the current hotness.

## Creating a development environment

I built this using Python 3.6.13, node.js 14.15.5 and Postgres 12.6.

1. Clone the repository into an appropriate location.

2. Set up your Python virtual environment by running `pyvenv venv` in that directory and running `source venv/bin/activate` to active it.

3. Install Python requirements with `pip install -r requirements.txt`.
   You may need to install some [build
   prerequisites](https://www.psycopg.org/docs/install.html#build-prerequisites);
   on Debian-like systems, they include the packages `python3-dev` and
   `libpq-dev`.

4. Install the frontend requirements with `npm install`.

5. [Install PostgreSQL](https://www.postgresql.org/download/)
   and create an empty database, e.g. `createdb rcniceties`

6. Set the following environment variables, noting that the application **will not run** if any of these is not set:
    * `FLASK_APP` - the location of the app, e.g. `backend:app`
    * `FLASK_SECRET_KEY_B64` - a base64-encoded random secret string, for example generated by running:
        ```python
        from base64 import b64encode
        from os import urandom
        print(b64encode(urandom(24)))
        ```
    * `DATABASE_URL` - the database connection URL `e.g. postgres://localhost/rcniceties`
    * `RC_OAUTH_ID` - your Recurse Center OAuth application ID
    * `RC_OAUTH_SECRET` - your Recurse Center OAuth application secret
    * `RC_API_ACCESS_TOKEN` - your Recurse Center personal access token
    * `DEV` - set to either `TRUE` or `FALSE`, depending on if this is a development or production environment
    * `DEBUG_SHOW_ALL` (optional) - set to `TRUE` to show every nicety in the DB on the Niceties For Me page (useful for debugging) or `FALSE` (default) for normal behavior

   A common way of setting up these environment variables is with a `.env` file in your project directory, containing `export ENV_VAR=value` on each line. This can be loaded by running `source .env` and will be automatically loaded by `heroku local`.

7. Optionally mock out the RC API by setting `MOCK_OUT_RC_API = True` in `backend/__init__.py`. This means you do not have to set `RC_OAUTH_ID` or `RC_OAUTH_SECRET`, but you'll only get sample data (contained in the `mock/fixtures` folder, and with request -> filename mapping in `mock/rc.py`). Alternatively, you'll need to [set up an RC application](https://recurse.com/settings/oauth) with a redirect URI pointing to your local server (e.g. `http://localhost:8000/login/authorized`) or with the special value `urn:ietf:wg:oauth:2.0:oob`.

8. At the command prompt, run `flask db upgrade` to create the DB tables.

9. Run `python`, and inside it run:

    ```python
    from backend import config
    config.set_to_default()
    ```

To run:

1. Compile the frontend static files by running `npm run build`.

2. Run the Flask application with `gunicorn backend:app --log-file -`.

## Deploying

This is designed to be deployed to Heroku. To do this:

1. Enable the Python and node.js buildpacks for the application.

2. Set up a Postgres database for the application and run `heroku pg:push [database-name] DATABASE_URL` to copy your local database to Heroku.

3. We can schedule data updates using the
[Heroku Scheduler](https://devcenter.heroku.com/articles/scheduler):

    ```sh
    $ heroku addons:create scheduler:standard
    $ heroku addons:open scheduler
    ```

    Create a new job that runs daily, and set the command to `./update-data.py`

    Then, in theory, it should be a simple `git push heroku main`!
